use anyhow::{bail, Result};
use chrono::{DateTime, Utc};
use std::time::{SystemTime, Duration, UNIX_EPOCH};

use serde::{Serialize, Deserialize};


use core::str;
use embedded_svc::{
    http::{client::Client, Method},
    io::Read,
};
use esp_idf_hal::delay::FreeRtos;
use esp_idf_hal::adc::attenuation::DB_11;
use esp_idf_hal::adc::oneshot::config::AdcChannelConfig;


use esp_idf_svc::{
    nvs::EspDefaultNvsPartition,
    eventloop::EspSystemEventLoop,

    http::client::{Configuration, EspHttpConnection},
    sntp::{EspSntp, SyncStatus},
};


use esp_idf_hal::peripherals::Peripherals;

use serde_json::json;

use esp_idf_hal::adc::oneshot::*;



mod wifi;


const NUM_READINGS: usize = 3;
const ADC_DRY: i32 = 1540;
const ADC_WET: i32 = 3075;
const NODE_ID:  &str = "home_lab";
const SENSOR_ID:  &str = "humidity_1";
const ENDPOINT:  &str = "";


#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

fn main(){
    esp_idf_svc::sys::link_patches();
    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take().unwrap();
    let sys_loop = EspSystemEventLoop::take().unwrap();
    let nvs = EspDefaultNvsPartition::take().unwrap();


    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;


    loop {

        // Connect to the Wi-Fi network
        let _wifi = wifi::wifi(
            app_config.wifi_ssid,
            app_config.wifi_psk,
            peripherals.modem,
            sys_loop,
        ).unwrap();

        // Sync with NTP server
        let ntp = EspSntp::new_default().unwrap();
        println!("Synchronizing with NTP Server");
        while ntp.get_sync_status() != SyncStatus::Completed {}
        println!("Time Sync Completed");

        // Read humidity
        let adc = AdcDriver::new(peripherals.adc1).unwrap();
        let config = AdcChannelConfig {
            attenuation: DB_11,
            calibration: true,
            ..Default::default()
        };
        let mut adc_pin = AdcChannelDriver::new(&adc, peripherals.pins.gpio36, &config).unwrap();
        let mut sum = 0;
        for _ in 0..NUM_READINGS {
            sum += adc.read(&mut adc_pin).unwrap()
        }
        println!("ADC value: {}", translate_adc_to_humidity(sum as i32));

        // Obtain System Time
        let st_now = SystemTime::now();
        // Convert to UTC Time
        let since_the_epoch = st_now
            .duration_since(UNIX_EPOCH)
            .expect("Time went backwards");

        let unix_ts = since_the_epoch.as_secs();
        let dt_now_utc: DateTime<Utc> = st_now.clone().into();
        // Format Time String
        let formatted = format!("{}", dt_now_utc.format("%d/%m/%Y %H:%M:%S"));

        post_data(vec!(HumidityReading {
            humidity: translate_adc_to_humidity(sum as i32),
            timestamp: unix_ts as i32,
            sensor_id: SENSOR_ID.to_string(),
            node_id: NODE_ID.to_string()
        }));
        unsafe {
            println!("{}", formatted);
            println!("About to get to sleep now. Will wake up automatically in 5 seconds");

            // Deep sleep doesn't work with power bank as it has auto switch off
            esp_idf_svc::sys::esp_deep_sleep(Duration::from_secs(300).as_micros() as u64);
        }
    }

}


fn translate_adc_to_humidity(adc_value: i32) -> i32 {
    let clamped_value = adc_value.clamp(ADC_DRY, ADC_WET);
    ((clamped_value - ADC_DRY) as f32 / (ADC_WET - ADC_DRY) as f32 * 100.0) as i32
}


#[derive(Debug, Serialize, Deserialize)]
struct HumidityReading {
    humidity: i32,
    timestamp: i32,
    sensor_id: String,
    node_id: String
}

#[derive(Debug, Serialize, Deserialize)]
struct HumidityServerPayload {
    events: Vec<HumidityReading>,
    timestamp: i32,
    node_id: String
}



fn post_data(humidityList: Vec<HumidityReading>) -> Result<()> {

    let st_now = SystemTime::now();
    let since_the_epoch = st_now
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards");

    let unix_ts = since_the_epoch.as_secs();

    let payload = HumidityServerPayload {
        events: humidityList,
        timestamp: unix_ts as i32,
        node_id: NODE_ID.to_string()
    };

    let json = json!(payload).to_string();
    let content_length = json.len().to_string();

    // 1. Create a new EspHttpClient. (Check documentation)
    // ANCHOR: connection
    let connection = EspHttpConnection::new(&Configuration {
        use_global_ca_store: true,
        crt_bundle_attach: Some(esp_idf_svc::sys::esp_crt_bundle_attach),
        ..Default::default()
    })?;
    // ANCHOR_END: connection
    let mut client = Client::wrap(connection);
    let ep = ENDPOINT;
    // 2. Open a GET request to `url`
    let headers = [("accept", "application/json"),
                   ("Content-Length", &content_length)];
    let mut request = client.request(Method::Post, ep.as_ref(), &headers)?;

    request.write(json.as_bytes())?;


    // 3. Submit write request and check the status code of the response.
    // Successful http status codes are in the 200..=299 range.
    let response = request.submit()?;
    let status = response.status();

    println!("Response code: {}\n", status);

    match status {
        200..=299 => {
            println!("Request sucessful");
        }
        _ => bail!("Unexpected response code: {}", status),
    }

    Ok(())
}

#[test]
fn test_post_data(){
}
